//! IDE configuration and hie.yaml generation.

use crate::Project;
use std::fs;

/// Generate hie.yaml content for a project.
///
/// The hie.yaml file tells HLS (Haskell Language Server) how to load
/// the project. For multi-component projects, this is essential for
/// correct IDE integration.
pub fn generate_hie_yaml(project: &Project) -> String {
    if project.is_workspace() {
        generate_workspace_hie_yaml(project)
    } else {
        generate_simple_hie_yaml(project)
    }
}

/// Generate hie.yaml for a simple single-package project.
fn generate_simple_hie_yaml(project: &Project) -> String {
    let cabal_name = project
        .cabal_file
        .as_ref()
        .and_then(|p| p.file_stem())
        .and_then(|s| s.to_str())
        .unwrap_or(project.name());

    format!(
        r#"# HLS configuration for {}
# Generated by hx

cradle:
  cabal:
    - path: "./src"
      component: "lib:{}"
    - path: "./app"
      component: "exe:{}"
    - path: "./test"
      component: "test:{}-test"
"#,
        project.name(),
        cabal_name,
        cabal_name,
        cabal_name
    )
}

/// Generate hie.yaml for a workspace with multiple packages.
fn generate_workspace_hie_yaml(project: &Project) -> String {
    let mut components = String::new();

    for pkg in &project.workspace_packages {
        let pkg_name = &pkg.name;
        let pkg_path = pkg.path.display();

        components.push_str(&format!(
            r#"    - path: "./{}/src"
      component: "lib:{}"
    - path: "./{}/app"
      component: "exe:{}"
    - path: "./{}/test"
      component: "test:{}-test"
"#,
            pkg_path, pkg_name, pkg_path, pkg_name, pkg_path, pkg_name
        ));
    }

    format!(
        r#"# HLS configuration for {} workspace
# Generated by hx
#
# This file tells HLS how to load the multi-package project.
# Components are detected from cabal.project packages.

cradle:
  cabal:
{}
"#,
        project.name(),
        components
    )
}

/// Check if hie.yaml exists and is up to date.
pub fn check_hie_yaml(project: &Project) -> HieYamlStatus {
    let hie_path = project.root.join("hie.yaml");

    if !hie_path.exists() {
        return HieYamlStatus::Missing;
    }

    // Check if it was generated by hx (has our comment marker)
    let content = match fs::read_to_string(&hie_path) {
        Ok(c) => c,
        Err(_) => return HieYamlStatus::Exists,
    };

    if content.contains("Generated by hx") {
        // Check if workspace structure changed
        if project.is_workspace() {
            let expected = generate_hie_yaml(project);
            if content.trim() != expected.trim() {
                return HieYamlStatus::Outdated;
            }
        }
        HieYamlStatus::UpToDate
    } else {
        HieYamlStatus::Exists
    }
}

/// Write hie.yaml to the project root.
pub fn write_hie_yaml(project: &Project) -> std::io::Result<()> {
    let hie_path = project.root.join("hie.yaml");
    let content = generate_hie_yaml(project);
    fs::write(hie_path, content)
}

/// Status of hie.yaml file.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum HieYamlStatus {
    /// hie.yaml does not exist
    Missing,
    /// hie.yaml exists but was not generated by hx
    Exists,
    /// hie.yaml exists, generated by hx, and is current
    UpToDate,
    /// hie.yaml exists, generated by hx, but needs update
    Outdated,
}

impl HieYamlStatus {
    /// Check if hie.yaml needs to be created or updated.
    pub fn needs_update(&self) -> bool {
        matches!(self, HieYamlStatus::Missing | HieYamlStatus::Outdated)
    }
}

/// Known HLS/GHC version compatibility matrix.
///
/// Returns true if the HLS version is compatible with the GHC version.
pub fn is_hls_compatible(hls_version: &str, ghc_version: &str) -> bool {
    // HLS compatibility is complex and changes frequently.
    // This is a simplified check based on major/minor versions.
    // See: https://haskell-language-server.readthedocs.io/en/latest/support/ghc-version-support.html

    let hls_major_minor = parse_major_minor(hls_version);
    let ghc_major_minor = parse_major_minor(ghc_version);

    match (hls_major_minor, ghc_major_minor) {
        (Some((hls_major, hls_minor)), Some((ghc_major, _ghc_minor))) => {
            // HLS 2.x supports GHC 9.x
            if hls_major >= 2 {
                return ghc_major >= 9;
            }
            // HLS 1.x supports GHC 8.x and 9.x
            if hls_major == 1 && hls_minor >= 5 {
                return (8..=9).contains(&ghc_major);
            }
            // Older versions - assume compatible within same GHC major
            true
        }
        _ => true, // If we can't parse, assume compatible
    }
}

/// Get recommended HLS version for a GHC version.
pub fn recommended_hls_for_ghc(ghc_version: &str) -> Option<&'static str> {
    let ghc_major_minor = parse_major_minor(ghc_version)?;

    match ghc_major_minor {
        (9, 10) => Some("2.9.0.0"),
        (9, 8) => Some("2.9.0.0"),
        (9, 6) => Some("2.9.0.0"),
        (9, 4) => Some("2.5.0.0"),
        (9, 2) => Some("2.2.0.0"),
        (8, 10) => Some("1.10.0.0"),
        _ => None,
    }
}

fn parse_major_minor(version: &str) -> Option<(u32, u32)> {
    let parts: Vec<&str> = version.split('.').collect();
    if parts.len() >= 2 {
        let major = parts[0].parse().ok()?;
        let minor = parts[1].parse().ok()?;
        Some((major, minor))
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hls_compatibility() {
        assert!(is_hls_compatible("2.9.0.0", "9.8.2"));
        assert!(is_hls_compatible("2.9.0.0", "9.6.4"));
        assert!(is_hls_compatible("2.5.0.0", "9.4.8"));
    }

    #[test]
    fn test_recommended_hls() {
        assert_eq!(recommended_hls_for_ghc("9.8.2"), Some("2.9.0.0"));
        assert_eq!(recommended_hls_for_ghc("9.6.4"), Some("2.9.0.0"));
        assert_eq!(recommended_hls_for_ghc("8.10.7"), Some("1.10.0.0"));
    }
}
